# Graphics pipeline states

## Color blending

How fragments are blended between dst (already on target) and src (from fragment shader).

There are 2 blending processes :
- **Normal blending** :
    - Per attachment (from `render_pass` or `dynamic_rendering`).
    - Alpha & Color are blended differently.
    - Formula : `new_dst = src * src_factor <blend_op> dst * dst_factor`.
- **Logic (bitwise) blending** :
    - For all attachments.
    - Only with integer formats.
    - Formula : `new_dst = src <logic_op> dst`.

If both blending processes are disabled, formula is `new_dst = src` (replace).
But writes are *still masked* (even if no blending) by their attachment's color write mask.

```rust
let color_blend_state = vk::PipelineColorBlendStateCreateInfo::default()
    // normal blending
    .attachments(attachments)
    .blend_constants(blend_constants)
    // logic blending
    .logic_op_enable(logic_op_enable)
    .logic_op(logic_op)
    // optional
    .flags(flags)
    .push_next(next);
```

- `blend_constants` : Used for some normal blending ops.
- `logic_op_enable` : Enable logic blending. Overwrite normal blending.

```rust
let attachment = vk::PipelineColorBlendAttachmentState::default()
    .color_write_mask(color_write_mask)
    .blend_enable(blend_enable)
    // color blend
    .src_color_blend_factor(src_color_blend_factor)
    .dst_color_blend_factor(dst_color_blend_factor)
    .color_blend_op(color_blend_op)
    // alpha blend
    .src_alpha_blend_factor(src_alpha_blend_factor)
    .dst_alpha_blend_factor(dst_alpha_blend_factor)
    .alpha_blend_op(alpha_blend_op);
```

- `color_write_mask` : Filter channels that can be written on dst.
- `blend_enable` : Enable normal blending.

## Depth stencil

Test if fragments (from fragment shader) should be discarded.

There are 2 tests :
- **Depth test** :
    - Formula : `keep if : fragment_depth <compare_op> buffer_depth`.
    - `fragment_depth` is generated by the rasterizer (lerp from triangle's Z coordinates).
    - `buffer_depth` can be overwritten by `fragment_depth` on success.
    - Formula can be extended (feature) : `.. && min_depth_bounds <= fragment_depth <= max_depth_bounds`.
- **Stencil test** :
    - Formula : `keep if : buffer_stencil <compare_op> reference_stencil`.
    - `reference_stencil` is specified in code.
    - `buffer_stencil` can be overwritten by `reference_stencil` on success.
    - Front & Back triangles are tested differently.

```rust
let depth_stencil_state = vk::PipelineDepthStencilStateCreateInfo::default()
    // depth test
    .depth_test_enable(depth_test_enable)
    .depth_compare_op(depth_compare_op)
    .depth_write_enable(depth_write_enable)
    // depth bounds test
    .depth_bounds_test_enable(depth_bounds_test_enable)
    .min_depth_bounds(min_depth_bounds)
    .max_depth_bounds(max_depth_bounds)
    // stencil test
    .stencil_test_enable(stencil_test_enable)
    .front(front)
    .back(back)
    // optional
    .flags(flags);
```

- `depth_write_enable` : Overwrite `buffer_depth` with `fragment_depth` on success.
- `front` : Stencil for front-facing triangles.
- `back` : Stencil for back-facing triangles.

```rust
let stencil = vk::StencilOpState::default()
    // compare
    .compare_op(compare_op)
    .compare_mask(compare_mask)
    .reference(reference)
    // write
    .pass_op(pass_op)
    .fail_op(fail_op)
    .depth_fail_op(depth_fail_op)
    .write_mask(write_mask);
```

- `pass_op` : Stencil passed and depth passed.
- `fail_op` : Stencil failed (no account for depth).
- `depth_fail_op` : stencil passed and depth failed.

## Input assembly

Describe how input data (vertices + indices) should be assembled into primitives.

```rust
let input_assembly_state = vk::PipelineInputAssemblyStateCreateInfo::default()
    .topology(topology)
    .primitive_restart_enable(primitive_restart_enable)
    // optional
    .flags(flags);
```

- `topology` : POINT_LIST, TRIANGLE_FAN, etc. Goal is to reuse data as much as possible.
- `primitive_restart_enable` : Enable use of index that restart the topology (for TRIANGLE_FAN for example).

## Multisample (unfinished)

Describe how to compute and use fragment's coverage.

**Coverage** (in [0.;1.]) := How much a fragment is "present" on its pixel.
    
**Multisampling** := Compute *geometric coverage* by doing point-in-triangle tests on multiple samples per pixel (not just center).

**Alpha-to-coverage** : Use fragment's alpha to estimate *texture coverage*.
    - For textures like foliage (transparent in the middle).
    - alpha = 0 => no samples, alpha = 1 => all samples.
    - Provide anti-aliasing *even inside the texture*.

There are 2 levels of multisampling :
- **Normal multisampling** :
    - Fragment shader run once per fragment.
    - Check if samples are inside the triangle (coverage = samples inside / all samples).
- **Sample shading** :
    - Fragment shader run *per sample*.
    - Samples are used for coverage *and* better approximation.

`vk::PipelineMultisampleStateCreateInfo` :
- `rasterization_samples` : Number of samples per fragment (1 <=> no multisampling).
- `sample_mask` : Which samples are used in computations.
- sample shading :
    - `sample_shading_enable`
    - `min_sample_shading` : minimal fraction of shaded (run with fragment shader) samples. Ex : 0.5 => half samples will be shaded.
- `alpha_to_one_enable` : Force fragment's alpha to be one.
- `alpha_to_coverage_enable`
- `flags`
- `push_next`

## Rasterization

Describe how fragments (and their depth) are generated from primitives.

**Mode** : What fragments should be generated from a primitive.

**Culling** : Remove fragments based on facing.

**Depth clamping** : Clamp depth to `[depth_min;depth_max]` (from viewport configuration).

**Depth bias** : Add a bias to depth. Formula : `bias = slope_factor * depth_derivative + constant_factor` (eventually clamped).

```rust
let rasterization_state = vk::PipelineRasterizationStateCreateInfo::default()
    .rasterizer_discard_enable(rasterizer_discard_enable)
    // mode
    .polygon_mode(polygon_mode)
    .line_width(line_width)
    // culling
    .cull_mode(cull_mode)
    .front_face(front_face)
    // depth clamp
    .depth_clamp_enable(depth_clamp_enable)
    // depth bias
    .depth_bias_enable(depth_bias_enable)
    .depth_bias_constant_factor(depth_bias_constant_factor)
    .depth_bias_slope_factor(depth_bias_slope_factor)
    .depth_bias_clamp(depth_bias_clamp)
    // optional
    .flags(flags)
    .push_next(next);
```

- `rasterization_discard_enable` : Disable rasterization but *depth/stencil values are still written*.
- `polygon_mode` : How polygons are filled (FILL, LINES).
- `line_width` : `1.` is always supported and mandatory *even if using `FILL` polygon mode*.
- `cull_mode` : Which polygons to cull based on their facing (front or back).
- `front_face` : What is considered front ("clockwise" or "counterclockwise").
- `depth_bias_clamp` : Clamp bias to `[-value;value]`. Ignored if `0.`.

## Vertex input

Describe vertices layout (per buffer).

```rust
let vertex_input_state = vk::PipelineVertexInputStateCreateInfo::default()
    .vertex_binding_descriptions(vertex_binding_descriptions)
    .vertex_attribute_descriptions(vertex_attribute_descriptions)
    // optional
    .flags(flags)
    .push_next(next);
```

**Binding description** := Describe buffer.

```rust
let binding_description = vk::VertexInputBindingDescription::default()
    // shader access
    .binding(binding)
    // description
    .input_rate(input_rate)
    .stride(stride);
```

- `input_rate` : Per vertex or per instance.
- `stride` : Size per vertex or instance.

**Attributes description** (N per buffer) := Describes one vertex/instance attribute from a buffer.

```rust
let attribute_description = vk::VertexInputAttributeDescription::default()
    // shader access
    .binding(binding)
    .location(location)
    // description
    .offset(offset);
    .format(format)
```

- `location` : Vertex shader location (attribute bigger than max format (vec4) *need multiple locations*).
- `offset` : Offset of the attribute inside the vertex/instance.
- `format` : Format of the data (=> size).

## Viewport

Describe how to use the rendering surface (target can be cut or distorted).

```rust
let viewport_state = vk::PipelineViewportStateCreateInfo::default()
    .scissors(scissors)
    .viewports(viewports)
    // count
    .scissor_count(scissor_count)
    .viewport_count(viewport_count);
    // optional
    .flags(flags)
    .push_next(next);
```

- `scissors` / `viewports` : Can be multiple for multiview rendering.

When dynamic : Set `scissor_count` / `viewport_count` to the number of scissors and viewports you'll need but the scissors and viewports to empty.

**Viewport** := Maps NDC (Normalized Device Coordinates) to pixel coordinates. Can distort image.

```rust
let viewport = vk::Viewport::default()
    // origin
    .x(x)
    .y(y)
    // size
    .width(width)
    .height(height)
    // depth
    .min_depth(min_depth)
    .max_depth(max_depth);

// Khronos official tweak to have Y axis upward (default downward)
let viewport = viewport
    .y(height)
    .height(-height)
```

- `min_depth`/`max_depth` : Usually `[0.;1.]`.

**Scissor** := Cut fragments outside of it.

```rust
let scissor = vk::Rect2D::default()
    .offset(vk::Offset2D {
        x,
        y,
    })
    .extent(vk::Extent2D {
        width,
        height,
    });
```
